<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Novel Splitter RAG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        .chat-container {
            height: calc(100vh - 200px);
        }
        .markdown-body pre {
            background-color: #f3f4f6;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div id="app" class="container mx-auto p-4 max-w-4xl">
        <header class="mb-6 flex justify-between items-center">
            <h1 class="text-3xl font-bold text-blue-600">Novel Splitter RAG</h1>
            <div class="space-x-4">
                <button @click="currentTab = 'chat'" :class="{'text-blue-600 font-bold': currentTab === 'chat', 'text-gray-500': currentTab !== 'chat'}">Chat</button>
                <button @click="currentTab = 'ingest'" :class="{'text-blue-600 font-bold': currentTab === 'ingest', 'text-gray-500': currentTab !== 'ingest'}">Ingest</button>
            </div>
        </header>

        <!-- Ingest Tab -->
        <div v-if="currentTab === 'ingest'" class="bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-4">Novel Ingestion</h2>
            
            <div class="mb-4 flex space-x-2">
                <button @click="loadNovels" class="bg-gray-200 px-3 py-1 rounded text-sm hover:bg-gray-300">Refresh List</button>
                <label class="bg-green-500 text-white px-3 py-1 rounded text-sm hover:bg-green-600 cursor-pointer">
                    Upload Novel
                    <input type="file" class="hidden" @change="uploadNovel">
                </label>
            </div>

            <div v-if="loadingNovels" class="text-gray-500">Loading files...</div>
            
            <ul v-else class="space-y-2">
                <li v-for="novel in novels" :key="novel" class="flex justify-between items-center p-3 border rounded hover:bg-gray-50">
                    <span class="font-medium">{{ novel }}</span>
                    <div class="flex items-center space-x-2">
                        <input type="number" v-model="ingestLimits[novel]" placeholder="Max Scenes (0=All)" class="border rounded px-2 py-1 w-24 text-sm">
                        <button @click="ingestNovel(novel)" :disabled="ingesting" class="bg-blue-500 text-white px-3 py-1 rounded text-sm hover:bg-blue-600 disabled:bg-blue-300">
                            {{ ingesting ? 'Processing...' : 'Ingest' }}
                        </button>
                    </div>
                </li>
            </ul>
            <div v-if="novels.length === 0 && !loadingNovels" class="text-gray-500 italic">No .txt files found in data directory.</div>
        </div>

        <!-- Chat Tab -->
        <div v-if="currentTab === 'chat'" class="bg-white p-6 rounded-lg shadow-md flex flex-col h-[80vh]">
            <div class="flex-1 overflow-y-auto mb-4 space-y-4 pr-2" ref="chatContainer">
                <div v-for="(msg, index) in chatHistory" :key="index" :class="{'text-right': msg.role === 'user'}">
                    <div :class="{'bg-blue-100': msg.role === 'user', 'bg-gray-100': msg.role === 'assistant', 'bg-red-100': msg.role === 'error'}" 
                         class="inline-block p-3 rounded-lg max-w-[80%] text-left">
                        <div class="whitespace-pre-wrap">{{ msg.content }}</div>
                        
                        <!-- Citations -->
                        <div v-if="msg.citations && msg.citations.length > 0" class="mt-2 pt-2 border-t border-gray-300 text-xs text-gray-600">
                            <div class="font-semibold mb-1">Citations:</div>
                            <div v-for="(cite, i) in msg.citations" :key="i" class="mb-1">
                                <span class="font-mono bg-gray-200 px-1 rounded">{{ cite.chunkId.substring(0,8) }}...</span>
                                <span v-if="cite.reason"> - {{ cite.reason }}</span>
                            </div>
                        </div>
                        <div v-if="msg.confidence" class="mt-1 text-xs text-gray-400 text-right">Confidence: {{ msg.confidence }}</div>
                    </div>
                </div>
                <div v-if="isThinking" class="text-gray-500 text-sm italic">Thinking...</div>
            </div>

            <div class="flex space-x-2">
                <input 
                    v-model="questionInput" 
                    @keyup.enter="sendMessage"
                    type="text" 
                    placeholder="Ask about the novel..." 
                    class="flex-1 border rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                    :disabled="isThinking"
                >
                <button 
                    @click="sendMessage" 
                    :disabled="isThinking || !questionInput.trim()"
                    class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 disabled:bg-blue-300 font-semibold"
                >
                    Send
                </button>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, onMounted, nextTick } = Vue;

        createApp({
            setup() {
                const currentTab = ref('chat');
                const novels = ref([]);
                const loadingNovels = ref(false);
                const ingestLimits = ref({});
                const ingesting = ref(false);

                const questionInput = ref('');
                const chatHistory = ref([
                    { role: 'assistant', content: 'Hello! I am your Novel RAG assistant. Ask me anything about the ingested novels.' }
                ]);
                const isThinking = ref(false);
                const chatContainer = ref(null);

                // --- Ingest Logic ---
                const loadNovels = async () => {
                    loadingNovels.value = true;
                    try {
                        const res = await fetch('/api/novels');
                        novels.value = await res.json();
                        novels.value.forEach(n => ingestLimits.value[n] = 0); // Default 0
                    } catch (e) {
                        alert('Failed to load novels: ' + e.message);
                    } finally {
                        loadingNovels.value = false;
                    }
                };

                const uploadNovel = async (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    const formData = new FormData();
                    formData.append('file', file);

                    try {
                        const res = await fetch('/api/novels/upload', {
                            method: 'POST',
                            body: formData
                        });
                        const data = await res.json();
                        if (res.ok) {
                            alert(data.message);
                            loadNovels(); // Refresh list
                        } else {
                            alert('Upload failed: ' + data.error);
                        }
                    } catch (e) {
                        alert('Upload failed: ' + e.message);
                    }
                };

                const ingestNovel = async (fileName) => {
                    if (!confirm(`Start ingestion for ${fileName}? This might take a while.`)) return;
                    
                    ingesting.value = true;
                    try {
                        const maxScenes = ingestLimits.value[fileName] || 0;
                        const res = await fetch('/api/novels/ingest', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ fileName, maxScenes })
                        });
                        const data = await res.json();
                        if (res.ok) {
                            alert('Ingestion started! Check server logs for progress.');
                        } else {
                            alert('Error: ' + data.error);
                        }
                    } catch (e) {
                        alert('Failed to start ingestion: ' + e.message);
                    } finally {
                        ingesting.value = false;
                    }
                };

                // --- Chat Logic ---
                const sendMessage = async () => {
                    const q = questionInput.value.trim();
                    if (!q || isThinking.value) return;

                    // Add User Message
                    chatHistory.value.push({ role: 'user', content: q });
                    questionInput.value = '';
                    isThinking.value = true;
                    scrollToBottom();

                    try {
                        const res = await fetch('/api/chat', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ question: q, topK: 3 })
                        });

                        if (!res.ok) throw new Error('Network response was not ok');

                        const data = await res.json();
                        
                        // Add Assistant Message
                        chatHistory.value.push({
                            role: 'assistant',
                            content: data.answer,
                            citations: data.citations,
                            confidence: data.confidence
                        });
                    } catch (e) {
                        chatHistory.value.push({ role: 'error', content: 'Error: ' + e.message });
                    } finally {
                        isThinking.value = false;
                        scrollToBottom();
                    }
                };

                const scrollToBottom = () => {
                    nextTick(() => {
                        if (chatContainer.value) {
                            chatContainer.value.scrollTop = chatContainer.value.scrollHeight;
                        }
                    });
                };

                onMounted(() => {
                    loadNovels();
                });

                return {
                    currentTab,
                    novels,
                    loadingNovels,
                    ingestLimits,
                    ingesting,
                    loadNovels,
                    uploadNovel,
                    ingestNovel,
                    questionInput,
                    chatHistory,
                    isThinking,
                    sendMessage,
                    chatContainer
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
